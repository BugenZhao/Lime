var max = |a, b| {
    if a > b { a; } else { b; }
};
var min = |a, b| {
    if a < b { a; } else { b; }
};
var add = |a, b| { a + b; };
var mul = |a, b| { a * b; };

var id = |x| { x; };

var assert_eq = |a, b| {
    if a &!= b { panic("Assertion failed:\n  left:", dbg(a), "\n right:", dbg(b)); }
    true;
};

var assert_ne = |a, b| {
    if a &== b { panic("Assertion failed:\n  left:", dbg(a), "\n right:", dbg(b)); }
    true;
};

impl Int {
    assoc abs = |self| {
        if self >= 0 { self; } else { -self; }
    };
}

impl Float {
    assoc abs = |self| {
        if self >= 0.0 { self; } else { -self; }
    };
}

class Pair { a, b }

impl Vec {
    assoc is_empty = |self| {
        self.len() == 0;
    };

    assoc clear = |self| {
        while !self.is_empty() {
            self.pop();
        }
        nil;
    };

    assoc iter = |self| {
        VecIter {
            vec: self,
            curr: 0,
            len: self.len(),
        };
    };

    assoc map = |self, fn| {
        var ret = [];
        for e in self {
            ret.push(fn(e));
        }
        ret;
    };

    assoc fold = |self, initial, fn| {
        var acc = initial;
        for e in self {
            acc = fn(acc, e);
        }
        acc;
    };

    assoc to_string = |self| {
        var ret = "[";
        var i = 0;
        while i < self.len() {
            ret = ret + self.get(i).to_string();
            if i != self.len() - 1 {
                ret = ret + ", ";
            }
            i = i + 1;
        }
        ret = ret + "]";
        ret;
    };
}

class VecIter { vec, curr, len }

impl VecIter {
    assoc iter = |self| { self; };

    assoc next = |self| {
        if self.curr >= self.len { nil.expect("stop iteration"); }
        else {
            var ans = self.vec.get(self.curr);
            self.curr = self.curr + 1;
            ans;
        }
    };
}
